// !!! This is a file automatically generated by hipify!!!
#include "caffe2/core/hip/common_gpu.h"

#include <atomic>
#include <cstdlib>
#include <iostream>
#include <sstream>

#include <c10/hip/HIPFunctions.h>

#include "caffe2/core/common.h"
#include "caffe2/core/init.h"
#include "caffe2/core/logging.h"

namespace caffe2 {

int NumHipDevices() {
  if (getenv("CAFFE2_DEBUG_HIP_INIT_ORDER")) {
    static bool first = true;
    if (first) {
      first = false;
      std::cerr << "DEBUG: caffe2::NumHipDevices() invoked for the first time"
                << std::endl;
    }
  }
  // It logs warnings on first run
  return c10::hip::device_count();
}

namespace {
int gDefaultGPUID = 0;
}  // namespace

void SetDefaultGPUID(const int deviceid) {
  CAFFE_ENFORCE_LT(
      deviceid,
      NumHipDevices(),
      "The default gpu id should be smaller than the number of gpus "
      "on this machine: ",
      deviceid,
      " vs ",
      NumHipDevices());
  gDefaultGPUID = deviceid;
}

int GetDefaultGPUID() { return gDefaultGPUID; }

int CaffeHipGetDevice() {
  int gpu_id = 0;
  HIP_ENFORCE(hipGetDevice(&gpu_id));
  return gpu_id;
}

void CaffeHipSetDevice(const int id) {
  HIP_ENFORCE(hipSetDevice(id));
}

int GetGPUIDForPointer(const void* ptr) {
  hipPointerAttribute_t attr;
  hipError_t err = hipPointerGetAttributes(&attr, ptr);

  if (err == hipErrorInvalidValue) {
    // Occurs when the pointer is in the CPU address space that is
    // unmanaged by HIP; make sure the last error state is cleared,
    // since it is persistent
    err = hipGetLastError();
    CHECK(err == hipErrorInvalidValue);
    return -1;
  }

  // Otherwise, there must be no error
  HIP_ENFORCE(err);

  if (attr.CAFFE2_HIP_PTRATTR_MEMTYPE == hipMemoryTypeHost) {
    return -1;
  }

  return attr.device;
}

struct HipDevicePropWrapper {
  HipDevicePropWrapper() : props(NumHipDevices()) {
    for (int i = 0; i < NumHipDevices(); ++i) {
      HIP_ENFORCE(hipGetDeviceProperties(&props[i], i));
    }
  }

  vector<hipDeviceProp_t> props;
};

const hipDeviceProp_t& GetDeviceProperty(const int deviceid) {
  // According to C++11 standard section 6.7, static local variable init is
  // thread safe. See
  //   https://stackoverflow.com/questions/8102125/is-local-static-variable-initialization-thread-safe-in-c11
  // for details.
  static HipDevicePropWrapper props;
  CAFFE_ENFORCE_LT(
      deviceid,
      NumHipDevices(),
      "The gpu id should be smaller than the number of gpus ",
      "on this machine: ",
      deviceid,
      " vs ",
      NumHipDevices());
  return props.props[deviceid];
}

void DeviceQuery(const int device) {
  const hipDeviceProp_t& prop = GetDeviceProperty(device);
  std::stringstream ss;
  ss << std::endl;
  ss << "Device id:                     " << device << std::endl;
  ss << "Major revision number:         " << prop.major << std::endl;
  ss << "Minor revision number:         " << prop.minor << std::endl;
  ss << "Name:                          " << prop.name << std::endl;
  ss << "Total global memory:           " << prop.totalGlobalMem << std::endl;
  ss << "Total shared memory per block: " << prop.sharedMemPerBlock
     << std::endl;
  ss << "Total registers per block:     " << prop.regsPerBlock << std::endl;
  ss << "Warp size:                     " << prop.warpSize << std::endl;
#if !defined(USE_ROCM)
  ss << "Maximum memory pitch:          " << prop.memPitch << std::endl;
#endif
  ss << "Maximum threads per block:     " << prop.maxThreadsPerBlock
     << std::endl;
  ss << "Maximum dimension of block:    "
     << prop.maxThreadsDim[0] << ", " << prop.maxThreadsDim[1] << ", "
     << prop.maxThreadsDim[2] << std::endl;
  ss << "Maximum dimension of grid:     "
     << prop.maxGridSize[0] << ", " << prop.maxGridSize[1] << ", "
     << prop.maxGridSize[2] << std::endl;
  ss << "Clock rate:                    " << prop.clockRate << std::endl;
  ss << "Total constant memory:         " << prop.totalConstMem << std::endl;
#if !defined(USE_ROCM)
  ss << "Texture alignment:             " << prop.textureAlignment << std::endl;
  ss << "Concurrent copy and execution: "
     << (prop.deviceOverlap ? "Yes" : "No") << std::endl;
#endif
  ss << "Number of multiprocessors:     " << prop.multiProcessorCount
     << std::endl;
#if !defined(USE_ROCM)
  ss << "Kernel execution timeout:      "
     << (prop.kernelExecTimeoutEnabled ? "Yes" : "No") << std::endl;
#endif
  LOG(INFO) << ss.str();
  return;
}

bool GetHipPeerAccessPattern(vector<vector<bool> >* pattern) {
  int gpu_count;
  if (hipGetDeviceCount(&gpu_count) != hipSuccess) return false;
  pattern->clear();
  pattern->resize(gpu_count, vector<bool>(gpu_count, false));
  for (int i = 0; i < gpu_count; ++i) {
    for (int j = 0; j < gpu_count; ++j) {
      int can_access = true;
      if (i != j) {
        if (hipDeviceCanAccessPeer(&can_access, i, j)
                 != hipSuccess) {
          return false;
        }
      }
      (*pattern)[i][j] = static_cast<bool>(can_access);
    }
  }
  return true;
}

bool TensorCoreAvailable() {
  int device = CaffeHipGetDevice();
  auto& prop = GetDeviceProperty(device);

  return prop.major >= 7;
}

const char* hipblasGetErrorString(hipblasStatus_t error) {
  switch (error) {
  case HIPBLAS_STATUS_SUCCESS:
    return "HIPBLAS_STATUS_SUCCESS";
  case HIPBLAS_STATUS_NOT_INITIALIZED:
    return "HIPBLAS_STATUS_NOT_INITIALIZED";
  case HIPBLAS_STATUS_ALLOC_FAILED:
    return "HIPBLAS_STATUS_ALLOC_FAILED";
  case HIPBLAS_STATUS_INVALID_VALUE:
    return "HIPBLAS_STATUS_INVALID_VALUE";
  case HIPBLAS_STATUS_ARCH_MISMATCH:
    return "HIPBLAS_STATUS_ARCH_MISMATCH";
  case HIPBLAS_STATUS_INTERNAL_ERROR:
    return "HIPBLAS_STATUS_INTERNAL_ERROR";
  case HIPBLAS_STATUS_MAPPING_ERROR:
    return "HIPBLAS_STATUS_MAPPING_ERROR";
  case HIPBLAS_STATUS_EXECUTION_FAILED:
    return "HIPBLAS_STATUS_EXECUTION_FAILED";
  case HIPBLAS_STATUS_NOT_SUPPORTED:
    return "HIPBLAS_STATUS_NOT_SUPPORTED";
#if !defined(USE_ROCM)
  case CUBLAS_STATUS_LICENSE_ERROR:
    return "CUBLAS_STATUS_LICENSE_ERROR";
#endif
  }
  // To suppress compiler warning.
  return "Unrecognized cublas error string";
}

const char* hiprandGetErrorString(hiprandStatus_t error) {
  switch (error) {
  case HIPRAND_STATUS_SUCCESS:
    return "HIPRAND_STATUS_SUCCESS";
  case HIPRAND_STATUS_VERSION_MISMATCH:
    return "HIPRAND_STATUS_VERSION_MISMATCH";
  case HIPRAND_STATUS_NOT_INITIALIZED:
    return "HIPRAND_STATUS_NOT_INITIALIZED";
  case HIPRAND_STATUS_ALLOCATION_FAILED:
    return "HIPRAND_STATUS_ALLOCATION_FAILED";
  case HIPRAND_STATUS_TYPE_ERROR:
    return "HIPRAND_STATUS_TYPE_ERROR";
  case HIPRAND_STATUS_OUT_OF_RANGE:
    return "HIPRAND_STATUS_OUT_OF_RANGE";
  case HIPRAND_STATUS_LENGTH_NOT_MULTIPLE:
    return "HIPRAND_STATUS_LENGTH_NOT_MULTIPLE";
  case HIPRAND_STATUS_DOUBLE_PRECISION_REQUIRED:
    return "HIPRAND_STATUS_DOUBLE_PRECISION_REQUIRED";
  case HIPRAND_STATUS_LAUNCH_FAILURE:
    return "HIPRAND_STATUS_LAUNCH_FAILURE";
  case HIPRAND_STATUS_PREEXISTING_FAILURE:
    return "HIPRAND_STATUS_PREEXISTING_FAILURE";
  case HIPRAND_STATUS_INITIALIZATION_FAILED:
    return "HIPRAND_STATUS_INITIALIZATION_FAILED";
  case HIPRAND_STATUS_ARCH_MISMATCH:
    return "HIPRAND_STATUS_ARCH_MISMATCH";
  case HIPRAND_STATUS_INTERNAL_ERROR:
    return "HIPRAND_STATUS_INTERNAL_ERROR";
#if defined(USE_ROCM)
  case HIPRAND_STATUS_NOT_IMPLEMENTED:
    return "HIPRAND_STATUS_NOT_IMPLEMENTED";
#endif
  }
  // To suppress compiler warning.
  return "Unrecognized hiprand error string";
}

// Turn on the flag g_caffe2_has_hip_linked to true for HasHipRuntime()
// function.
namespace {
class HipRuntimeFlagFlipper {
 public:
  HipRuntimeFlagFlipper() {
    internal::SetHipRuntimeFlag();
  }
};
static HipRuntimeFlagFlipper g_flipper;
} // namespace

}  // namespace caffe2
