// !!! This is a file automatically generated by hipify!!!
#include <gtest/gtest.h>

#include <ATen/hip/HIPContext.h>
#include <ATen/hip/HIPEvent.h>
#include <c10/core/Event.h>
#include <c10/core/impl/InlineEvent.h>
#include <ATen/hip/impl/HIPGuardImplMasqueradingAsCUDA.h>
#include <c10/hip/impl/HIPGuardImpl.h>
#include <c10/util/irange.h>

#include <hip/hip_runtime.h>

#include <functional>
#include <future>
#include <thread>
#include <unordered_set>

#define ASSERT_EQ_CUDA(X, Y) \
  {                          \
    bool isTRUE = X == Y;    \
    ASSERT_TRUE(isTRUE);     \
  }

#define ASSERT_NE_CUDA(X, Y) \
  {                          \
    bool isFALSE = X == Y;   \
    ASSERT_FALSE(isFALSE);   \
  }

/*
   Tests related to ATen streams.
   */
// Verifies streams are live through copying and moving
TEST(TestStream, CopyAndMoveTest) {
  if (!at::cuda::is_available()) return;
  int32_t device = -1;
  hipStream_t cuda_stream;

  // Tests that copying works as expected and preserves the stream
  at::hip::HIPStreamMasqueradingAsCUDA copyStream = at::hip::getStreamFromPoolMasqueradingAsCUDA();
  {
    auto s = at::hip::getStreamFromPoolMasqueradingAsCUDA();
    device = s.device_index();
    cuda_stream = s.stream();

    copyStream = s;

    ASSERT_EQ_CUDA(copyStream.device_index(), device);
    ASSERT_EQ_CUDA(copyStream.stream(), cuda_stream);
  }

  ASSERT_EQ_CUDA(copyStream.device_index(), device);
  ASSERT_EQ_CUDA(copyStream.stream(), cuda_stream);

  // Tests that moving works as expected and preserves the stream
  at::hip::HIPStreamMasqueradingAsCUDA moveStream = at::hip::getStreamFromPoolMasqueradingAsCUDA();
  {
    auto s = at::hip::getStreamFromPoolMasqueradingAsCUDA();
    device = s.device_index();
    cuda_stream = s.stream();

    moveStream = std::move(s);

    ASSERT_EQ_CUDA(moveStream.device_index(), device);
    ASSERT_EQ_CUDA(moveStream.stream(), cuda_stream);
  }

  ASSERT_EQ_CUDA(moveStream.device_index(), device);
  ASSERT_EQ_CUDA(moveStream.stream(), cuda_stream);
}

// Verifies streams are set properly
TEST(TestStream, GetAndSetTest) {
  if (!at::cuda::is_available()) return;
  at::hip::HIPStreamMasqueradingAsCUDA myStream = at::hip::getStreamFromPoolMasqueradingAsCUDA();

  // Sets and gets
  at::hip::setCurrentHIPStreamMasqueradingAsCUDA(myStream);
  at::hip::HIPStreamMasqueradingAsCUDA curStream = at::hip::getCurrentHIPStreamMasqueradingAsCUDA();

  ASSERT_EQ_CUDA(myStream, curStream);

  // Gets, sets, and gets default stream
  at::hip::HIPStreamMasqueradingAsCUDA defaultStream = at::hip::getDefaultHIPStreamMasqueradingAsCUDA();
  at::hip::setCurrentHIPStreamMasqueradingAsCUDA(defaultStream);
  curStream = at::hip::getCurrentHIPStreamMasqueradingAsCUDA();

  ASSERT_NE_CUDA(defaultStream, myStream);
  ASSERT_EQ_CUDA(curStream, defaultStream);
}

void thread_fun(at::optional<at::hip::HIPStreamMasqueradingAsCUDA>& cur_thread_stream) {
  auto new_stream = at::hip::getStreamFromPoolMasqueradingAsCUDA();
  at::hip::setCurrentHIPStreamMasqueradingAsCUDA(new_stream);
  cur_thread_stream = {at::hip::getCurrentHIPStreamMasqueradingAsCUDA()};
  ASSERT_EQ_CUDA(*cur_thread_stream, new_stream);
}

// Ensures streams are thread local
TEST(TestStream, MultithreadGetAndSetTest) {
  if (!at::cuda::is_available()) return;
  at::optional<at::hip::HIPStreamMasqueradingAsCUDA> s0, s1;

  std::thread t0{thread_fun, std::ref(s0)};
  std::thread t1{thread_fun, std::ref(s1)};
  t0.join();
  t1.join();

  at::hip::HIPStreamMasqueradingAsCUDA cur_stream = at::hip::getCurrentHIPStreamMasqueradingAsCUDA();
  at::hip::HIPStreamMasqueradingAsCUDA default_stream = at::hip::getDefaultHIPStreamMasqueradingAsCUDA();

  ASSERT_EQ_CUDA(cur_stream, default_stream);
  ASSERT_NE_CUDA(cur_stream, *s0);
  ASSERT_NE_CUDA(cur_stream, *s1);
  ASSERT_NE_CUDA(s0, s1);
}

// CUDA Guard
TEST(TestStream, CUDAGuardTest) {
  if (!at::cuda::is_available()) return;
  if (at::cuda::getNumGPUs() < 2) {
    return;
  }

  // -- begin setup

  ASSERT_EQ_CUDA(at::hip::current_device(), 0);
  std::vector<at::hip::HIPStreamMasqueradingAsCUDA> streams0 = {
      at::hip::getDefaultHIPStreamMasqueradingAsCUDA(), at::hip::getStreamFromPoolMasqueradingAsCUDA()};
  ASSERT_EQ_CUDA(streams0[0].device_index(), 0);
  ASSERT_EQ_CUDA(streams0[1].device_index(), 0);
  at::hip::setCurrentHIPStreamMasqueradingAsCUDA(streams0[0]);

  std::vector<at::hip::HIPStreamMasqueradingAsCUDA> streams1;
  {
    at::hip::HIPGuardMasqueradingAsCUDA device_guard(1);
    streams1.push_back(at::hip::getDefaultHIPStreamMasqueradingAsCUDA());
    streams1.push_back(at::hip::getStreamFromPoolMasqueradingAsCUDA());
  }
  ASSERT_EQ_CUDA(streams1[0].device_index(), 1);
  ASSERT_EQ_CUDA(streams1[1].device_index(), 1);
  at::hip::setCurrentHIPStreamMasqueradingAsCUDA(streams1[0]);

  ASSERT_EQ_CUDA(at::hip::current_device(), 0);

  // -- end setup

  // Setting a stream changes the current device and the stream on that device
  {
    at::hip::HIPStreamGuardMasqueradingAsCUDA guard(streams1[1]);
    ASSERT_EQ_CUDA(guard.current_device(), at::Device(at::kCUDA, 1));
    ASSERT_EQ_CUDA(at::hip::current_device(), 1);
    ASSERT_EQ_CUDA(at::hip::getCurrentHIPStreamMasqueradingAsCUDA(1), streams1[1]);
  }

  // Device and stream are now reset
  ASSERT_EQ_CUDA(at::hip::current_device(), 0);
  ASSERT_EQ_CUDA(at::hip::getCurrentHIPStreamMasqueradingAsCUDA(1), streams1[0]);

  // Setting only the device changes only the current device and not the stream
  {
    at::hip::HIPGuardMasqueradingAsCUDA guard(/*device=*/1);
    ASSERT_EQ_CUDA(guard.current_device(), at::Device(at::kCUDA, 1));
    ASSERT_EQ_CUDA(at::hip::current_device(), 1);
    ASSERT_EQ_CUDA(at::hip::getCurrentHIPStreamMasqueradingAsCUDA(1), streams1[0]);
  }

  ASSERT_EQ_CUDA(at::hip::current_device(), 0);
  ASSERT_EQ_CUDA(at::hip::getCurrentHIPStreamMasqueradingAsCUDA(0), streams0[0]);
}

// Streampool Round Robin
TEST(TestStream, StreamPoolTest) {
  if (!at::cuda::is_available()) return;
  std::vector<at::hip::HIPStreamMasqueradingAsCUDA> streams{};
  for (const auto i : c10::irange(200)) {
    (void)i;
    streams.emplace_back(at::hip::getStreamFromPoolMasqueradingAsCUDA());
  }

  std::unordered_set<hipStream_t> stream_set{};
  bool hasDuplicates = false;
  for (const auto i: c10::irange(streams.size())) {
    hipStream_t cuda_stream = streams[i];
    auto result_pair = stream_set.insert(cuda_stream);
    if (!result_pair.second)
      hasDuplicates = true;
  }

  ASSERT_TRUE(hasDuplicates);
}

// Multi-GPU
TEST(TestStream, MultiGPUTest) {
  if (!at::cuda::is_available()) return;
  if (at::cuda::getNumGPUs() < 2)
    return;

  at::hip::HIPStreamMasqueradingAsCUDA s0 = at::hip::getStreamFromPoolMasqueradingAsCUDA(true, 0);
  at::hip::HIPStreamMasqueradingAsCUDA s1 = at::hip::getStreamFromPoolMasqueradingAsCUDA(false, 1);

  at::hip::setCurrentHIPStreamMasqueradingAsCUDA(s0);
  at::hip::setCurrentHIPStreamMasqueradingAsCUDA(s1);

  ASSERT_EQ_CUDA(s0, at::hip::getCurrentHIPStreamMasqueradingAsCUDA());

  at::hip::HIPGuardMasqueradingAsCUDA device_guard{1};
  ASSERT_EQ_CUDA(s1, at::hip::getCurrentHIPStreamMasqueradingAsCUDA());
}

// CUDAEvent Syncs
TEST(TestStream, CUDAEventSyncTest) {
  if (!at::cuda::is_available()) return;
  const auto stream = at::hip::getStreamFromPoolMasqueradingAsCUDA();
  at::cuda::CUDAEvent event;

  ASSERT_TRUE(event.query());

  event.recordOnce(stream);

  const auto wait_stream0 = at::hip::getStreamFromPoolMasqueradingAsCUDA();
  const auto wait_stream1 = at::hip::getStreamFromPoolMasqueradingAsCUDA();

  event.block(wait_stream0);
  event.block(wait_stream1);

  hipStreamSynchronize(wait_stream0);
  ASSERT_TRUE(event.query());
}

// Cross-Device Events
TEST(TestStream, CrossDeviceTest) {
  if (!at::cuda::is_available()) return;
  if (at::cuda::getNumGPUs() < 2)
    return;

  const auto stream0 = at::hip::getStreamFromPoolMasqueradingAsCUDA();
  at::cuda::CUDAEvent event0;

  at::hip::set_device(1);
  const auto stream1 = at::hip::getStreamFromPoolMasqueradingAsCUDA();
  at::cuda::CUDAEvent event1;

  event0.record(stream0);
  event1.record(stream1);

  event0 = std::move(event1);

  ASSERT_EQ_CUDA(event0.device(), at::Device(at::kCUDA, 1));

  event0.block(stream0);

  hipStreamSynchronize(stream0);
  ASSERT_TRUE(event0.query());
}

// Generic Events
TEST(TestStream, GenericInlineCUDAEventTest) {
  if (!at::cuda::is_available()) return;

  c10::impl::InlineEvent<c10::hip::impl::CUDAGuardImpl> event{c10::DeviceType::CUDA};
  c10::Stream stream = at::hip::getStreamFromPoolMasqueradingAsCUDA();

  event.record(stream);

  const c10::Stream wait_stream0 = at::hip::getStreamFromPoolMasqueradingAsCUDA();
  const c10::Stream wait_stream1 = at::hip::getStreamFromPoolMasqueradingAsCUDA();

  event.block(wait_stream0);
  event.block(wait_stream1);

  const at::hip::HIPStreamMasqueradingAsCUDA cuda_stream{wait_stream0};
  hipStreamSynchronize(cuda_stream);

  ASSERT_TRUE(event.query());
}

TEST(TestStream, GenericVirtualCUDAEventTest) {
  if (!at::cuda::is_available()) return;

  c10::Event event{c10::DeviceType::CUDA};
  c10::Stream stream = at::hip::getStreamFromPoolMasqueradingAsCUDA();

  event.recordOnce(stream);

  const c10::Stream wait_stream0 = at::hip::getStreamFromPoolMasqueradingAsCUDA();
  const c10::Stream wait_stream1 = at::hip::getStreamFromPoolMasqueradingAsCUDA();

  wait_stream0.wait(event);
  wait_stream1.wait(event);

  const at::hip::HIPStreamMasqueradingAsCUDA cuda_stream{wait_stream0};
  hipStreamSynchronize(cuda_stream);

  ASSERT_TRUE(event.query());
  ASSERT_TRUE(event.flag() == c10::EventFlag::PYTORCH_DEFAULT);
}

// Verifies external streams can be created and used
TEST(TestStream, ExternalTest) {
  if (!at::cuda::is_available())
    return;
  at::hip::HIPGuardMasqueradingAsCUDA device_guard(0);

  hipStream_t cuda_stream;
  hipStreamCreateWithPriority(&cuda_stream, hipStreamNonBlocking, -1);

  at::hip::HIPStreamMasqueradingAsCUDA myStream =
      at::hip::getStreamFromExternalMasqueradingAsCUDA(cuda_stream, 0);

  at::hip::setCurrentHIPStreamMasqueradingAsCUDA(myStream);
  at::hip::HIPStreamMasqueradingAsCUDA curStream = at::hip::getCurrentHIPStreamMasqueradingAsCUDA();

  ASSERT_EQ_CUDA(curStream, myStream);
  ASSERT_EQ_CUDA(curStream.stream(), cuda_stream);

  hipStreamDestroy(cuda_stream);
}

// Verifies different external streams can be used for different devices at the
// same time
TEST(TestStream, ExternalMultiDeviceTest) {
  if (!at::cuda::is_available())
    return;
  if (at::cuda::getNumGPUs() < 2)
    return;
  hipStream_t cuda_stream_0;
  hipStream_t cuda_stream_1;
  {
    at::hip::HIPGuardMasqueradingAsCUDA device_guard(0);
    hipStreamCreateWithPriority(&cuda_stream_0, hipStreamNonBlocking, -1);
  }
  {
    at::hip::HIPGuardMasqueradingAsCUDA device_guard(1);
    hipStreamCreateWithPriority(&cuda_stream_1, hipStreamNonBlocking, -1);
  }
  at::hip::HIPStreamMasqueradingAsCUDA myStream0 =
      at::hip::getStreamFromExternalMasqueradingAsCUDA(cuda_stream_0, 0);
  at::hip::HIPStreamMasqueradingAsCUDA myStream1 =
      at::hip::getStreamFromExternalMasqueradingAsCUDA(cuda_stream_1, 1);

  at::hip::setCurrentHIPStreamMasqueradingAsCUDA(myStream0);
  ASSERT_EQ_CUDA(at::hip::getCurrentHIPStreamMasqueradingAsCUDA(0), myStream0);
  at::hip::setCurrentHIPStreamMasqueradingAsCUDA(myStream1);
  ASSERT_EQ_CUDA(at::hip::getCurrentHIPStreamMasqueradingAsCUDA(0), myStream0);
  ASSERT_EQ_CUDA(at::hip::getCurrentHIPStreamMasqueradingAsCUDA(1), myStream1);

  hipStreamDestroy(cuda_stream_0);
  hipStreamDestroy(cuda_stream_1);
}

// Verifies external streams work with guards, even nested ones
TEST(TestStream, ExternalGuardTest) {
  if (!at::cuda::is_available())
    return;
  at::hip::HIPGuardMasqueradingAsCUDA device_guard(0);

  hipStream_t a_cuda_stream;
  hipStream_t another_cuda_stream;
  hipStreamCreateWithPriority(&a_cuda_stream, hipStreamNonBlocking, -1);
  hipStreamCreateWithPriority(&another_cuda_stream, hipStreamNonBlocking, -1);
  at::hip::HIPStreamMasqueradingAsCUDA myFirstStream =
      at::hip::getStreamFromExternalMasqueradingAsCUDA(a_cuda_stream, 0);
  at::hip::HIPStreamMasqueradingAsCUDA mySecondStream =
      at::hip::getStreamFromExternalMasqueradingAsCUDA(another_cuda_stream, 0);

  at::hip::HIPStreamMasqueradingAsCUDA originalStream = at::hip::getCurrentHIPStreamMasqueradingAsCUDA();
  {
    at::hip::HIPStreamGuardMasqueradingAsCUDA outerGuard(myFirstStream);
    ASSERT_EQ_CUDA(outerGuard.original_stream(), originalStream);
    ASSERT_EQ_CUDA(outerGuard.current_stream(), myFirstStream);
    ASSERT_EQ_CUDA(at::hip::getCurrentHIPStreamMasqueradingAsCUDA(), myFirstStream);
    {
      at::hip::HIPStreamGuardMasqueradingAsCUDA innerGuard(mySecondStream);
      ASSERT_EQ_CUDA(innerGuard.original_stream(), myFirstStream);
      ASSERT_EQ_CUDA(innerGuard.current_stream(), mySecondStream);
      ASSERT_EQ_CUDA(at::hip::getCurrentHIPStreamMasqueradingAsCUDA(), mySecondStream);
    }
    ASSERT_EQ_CUDA(outerGuard.original_stream(), originalStream);
    ASSERT_EQ_CUDA(outerGuard.current_stream(), myFirstStream);
    ASSERT_EQ_CUDA(at::hip::getCurrentHIPStreamMasqueradingAsCUDA(), myFirstStream);
    outerGuard.reset_stream(mySecondStream);
    ASSERT_EQ_CUDA(outerGuard.original_stream(), originalStream);
    ASSERT_EQ_CUDA(outerGuard.current_stream(), mySecondStream);
    ASSERT_EQ_CUDA(at::hip::getCurrentHIPStreamMasqueradingAsCUDA(), mySecondStream);
  }
  ASSERT_EQ_CUDA(at::hip::getCurrentHIPStreamMasqueradingAsCUDA(), originalStream);

  hipStreamDestroy(a_cuda_stream);
  hipStreamDestroy(another_cuda_stream);
}

// Verifies that different threads stage their external streams to different
// places in memory and thus don't interfere
TEST(TestStream, ExternalMultiThreadTest) {
  if (!at::cuda::is_available())
    return;
  at::hip::HIPGuardMasqueradingAsCUDA device_guard(0);

  hipStream_t cuda_stream_a;
  hipStream_t cuda_stream_b;
  hipStreamCreateWithPriority(&cuda_stream_a, hipStreamNonBlocking, -1);
  hipStreamCreateWithPriority(&cuda_stream_b, hipStreamNonBlocking, -1);
  at::hip::HIPStreamMasqueradingAsCUDA myStreamA =
      at::hip::getStreamFromExternalMasqueradingAsCUDA(cuda_stream_a, 0);
  at::hip::HIPStreamMasqueradingAsCUDA myStreamB =
      at::hip::getStreamFromExternalMasqueradingAsCUDA(cuda_stream_b, 0);

  std::promise<void> aToBProm;
  std::promise<void> bToAProm;
  c10::optional<at::hip::HIPStreamMasqueradingAsCUDA> foundStream;

  std::thread threadA([&]() {
    at::hip::HIPGuardMasqueradingAsCUDA device_guard(0);
    at::hip::setCurrentHIPStreamMasqueradingAsCUDA(myStreamA);
    aToBProm.set_value();
    bToAProm.get_future().wait();
    foundStream = at::hip::getCurrentHIPStreamMasqueradingAsCUDA();
  });

  std::thread threadB([&]() {
    at::hip::HIPGuardMasqueradingAsCUDA device_guard(0);
    aToBProm.get_future().wait();
    at::hip::setCurrentHIPStreamMasqueradingAsCUDA(myStreamB);
    bToAProm.set_value();
  });

  threadA.join();
  threadB.join();

  ASSERT_EQ_CUDA(*foundStream, myStreamA);

  hipStreamDestroy(cuda_stream_a);
  hipStreamDestroy(cuda_stream_b);
}
